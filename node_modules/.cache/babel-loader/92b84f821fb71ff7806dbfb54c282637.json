{"ast":null,"code":"'use strict';\n\nconst buildRouteTree = require('./route-tree').build;\n\nconst generateEndpointFactories = require('./endpoint-factories').generate;\n\nconst paramSetter = require('./util/parameter-setter');\n\nconst applyMixin = require('./util/apply-mixin');\n\nconst mixins = require('./mixins');\n/**\n * Create and return a handler for an arbitrary WP REST API endpoint.\n *\n * The first two parameters mirror `register_rest_route` in the REST API\n * codebase:\n *\n * @memberof! WPAPI#\n * @param {string}   namespace         A namespace string, e.g. 'myplugin/v1'\n * @param {string}   restBase          A REST route string, e.g. '/author/(?P<id>\\d+)'\n * @param {object}   [options]         An (optional) options object\n * @param {object}   [options.mixins]  A hash of functions to apply as mixins\n * @param {string[]} [options.methods] An array of methods to whitelist (on the leaf node only)\n * @returns {Function} An endpoint handler factory function for the specified route\n */\n\n\nfunction registerRoute(namespace, restBase, options = {}) {\n  // Support all methods until requested to do otherwise\n  let supportedMethods = ['head', 'get', 'patch', 'put', 'post', 'delete'];\n\n  if (Array.isArray(options.methods)) {\n    // Permit supported methods to be specified as an array\n    supportedMethods = options.methods.map(method => method.trim().toLowerCase());\n  } else if (typeof options.methods === 'string') {\n    // Permit a supported method to be specified as a string\n    supportedMethods = [options.methods.trim().toLowerCase()];\n  } // Ensure that if GET is supported, then HEAD is as well, and vice-versa\n\n\n  if (supportedMethods.indexOf('get') !== -1 && supportedMethods.indexOf('head') === -1) {\n    supportedMethods.push('head');\n  } else if (supportedMethods.indexOf('head') !== -1 && supportedMethods.indexOf('get') === -1) {\n    supportedMethods.push('get');\n  }\n\n  const fullRoute = namespace // Route should always have preceding slash\n  .replace(/^[\\s/]*/, '/') // Route should always be joined to namespace with a single slash\n  .replace(/[\\s/]*$/, '/') + restBase.replace(/^[\\s/]*/, '');\n  const routeObj = {};\n  routeObj[fullRoute] = {\n    namespace: namespace,\n    methods: supportedMethods\n  }; // Go through the same steps used to bootstrap the client to parse the\n  // provided route out into a handler request method\n\n  const routeTree = buildRouteTree(routeObj); // Parse the mock route object into endpoint factories\n\n  const endpointFactories = generateEndpointFactories(routeTree)[namespace];\n  const EndpointRequest = endpointFactories[Object.keys(endpointFactories)[0]].Ctor;\n\n  if (options && options.params) {\n    options.params.forEach(param => {\n      // Only accept string parameters\n      if (typeof param !== 'string') {\n        return;\n      } // If the parameter can be mapped to a mixin, apply that mixin\n\n\n      if (typeof mixins[param] === 'object') {\n        Object.keys(mixins[param]).forEach(key => {\n          applyMixin(EndpointRequest.prototype, key, mixins[param][key]);\n        });\n        return;\n      } // Attempt to create a simple setter for any parameters for which\n      // we do not already have a custom mixin\n\n\n      applyMixin(EndpointRequest.prototype, param, paramSetter(param));\n    });\n  } // Set any explicitly-provided object mixins\n\n\n  if (options && typeof options.mixins === 'object') {\n    // Set any specified mixin functions on the response\n    Object.keys(options.mixins).forEach(key => {\n      applyMixin(EndpointRequest.prototype, key, options.mixins[key]);\n    });\n  }\n\n  function endpointFactory(options = {}) {\n    return new EndpointRequest({ ...options,\n      ...(this ? this._options : {})\n    });\n  }\n\n  endpointFactory.Ctor = EndpointRequest;\n  return endpointFactory;\n}\n\nmodule.exports = registerRoute;","map":{"version":3,"sources":["/Users/hiromi/ionic-react-wordpress/node_modules/wpapi/lib/wp-register-route.js"],"names":["buildRouteTree","require","build","generateEndpointFactories","generate","paramSetter","applyMixin","mixins","registerRoute","namespace","restBase","options","supportedMethods","Array","isArray","methods","map","method","trim","toLowerCase","indexOf","push","fullRoute","replace","routeObj","routeTree","endpointFactories","EndpointRequest","Object","keys","Ctor","params","forEach","param","key","prototype","endpointFactory","_options","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst buildRouteTree = require( './route-tree' ).build;\nconst generateEndpointFactories = require( './endpoint-factories' ).generate;\nconst paramSetter = require( './util/parameter-setter' );\nconst applyMixin = require( './util/apply-mixin' );\nconst mixins = require( './mixins' );\n\n/**\n * Create and return a handler for an arbitrary WP REST API endpoint.\n *\n * The first two parameters mirror `register_rest_route` in the REST API\n * codebase:\n *\n * @memberof! WPAPI#\n * @param {string}   namespace         A namespace string, e.g. 'myplugin/v1'\n * @param {string}   restBase          A REST route string, e.g. '/author/(?P<id>\\d+)'\n * @param {object}   [options]         An (optional) options object\n * @param {object}   [options.mixins]  A hash of functions to apply as mixins\n * @param {string[]} [options.methods] An array of methods to whitelist (on the leaf node only)\n * @returns {Function} An endpoint handler factory function for the specified route\n */\nfunction registerRoute( namespace, restBase, options = {} ) {\n\t// Support all methods until requested to do otherwise\n\tlet supportedMethods = [ 'head', 'get', 'patch', 'put', 'post', 'delete' ];\n\n\tif ( Array.isArray( options.methods ) ) {\n\t\t// Permit supported methods to be specified as an array\n\t\tsupportedMethods = options.methods.map( method => method.trim().toLowerCase() );\n\t} else if ( typeof options.methods === 'string' ) {\n\t\t// Permit a supported method to be specified as a string\n\t\tsupportedMethods = [ options.methods.trim().toLowerCase() ];\n\t}\n\n\t// Ensure that if GET is supported, then HEAD is as well, and vice-versa\n\tif ( supportedMethods.indexOf( 'get' ) !== -1 && supportedMethods.indexOf( 'head' ) === -1 ) {\n\t\tsupportedMethods.push( 'head' );\n\t} else if ( supportedMethods.indexOf( 'head' ) !== -1 && supportedMethods.indexOf( 'get' ) === -1 ) {\n\t\tsupportedMethods.push( 'get' );\n\t}\n\n\tconst fullRoute = namespace\n\t\t// Route should always have preceding slash\n\t\t.replace( /^[\\s/]*/, '/' )\n\t\t// Route should always be joined to namespace with a single slash\n\t\t.replace( /[\\s/]*$/, '/' ) + restBase.replace( /^[\\s/]*/, '' );\n\n\tconst routeObj = {};\n\trouteObj[ fullRoute ] = {\n\t\tnamespace: namespace,\n\t\tmethods: supportedMethods,\n\t};\n\n\t// Go through the same steps used to bootstrap the client to parse the\n\t// provided route out into a handler request method\n\tconst routeTree = buildRouteTree( routeObj );\n\t// Parse the mock route object into endpoint factories\n\tconst endpointFactories = generateEndpointFactories( routeTree )[ namespace ];\n\tconst EndpointRequest = endpointFactories[ Object.keys( endpointFactories )[ 0 ] ].Ctor;\n\n\tif ( options && options.params ) {\n\t\toptions.params.forEach( ( param ) => {\n\t\t\t// Only accept string parameters\n\t\t\tif ( typeof param !== 'string' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If the parameter can be mapped to a mixin, apply that mixin\n\t\t\tif ( typeof mixins[ param ] === 'object' ) {\n\t\t\t\tObject.keys( mixins[ param ] ).forEach( ( key ) => {\n\t\t\t\t\tapplyMixin( EndpointRequest.prototype, key, mixins[ param ][ key ] );\n\t\t\t\t} );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Attempt to create a simple setter for any parameters for which\n\t\t\t// we do not already have a custom mixin\n\t\t\tapplyMixin( EndpointRequest.prototype, param, paramSetter( param ) );\n\t\t} );\n\t}\n\n\t// Set any explicitly-provided object mixins\n\tif ( options && typeof options.mixins === 'object' ) {\n\n\t\t// Set any specified mixin functions on the response\n\t\tObject.keys( options.mixins ).forEach( ( key ) => {\n\t\t\tapplyMixin( EndpointRequest.prototype, key, options.mixins[ key ] );\n\t\t} );\n\t}\n\n\tfunction endpointFactory( options = {} ) {\n\t\treturn new EndpointRequest( {\n\t\t\t...options,\n\t\t\t...( this ? this._options : {} ),\n\t\t} );\n\t}\n\tendpointFactory.Ctor = EndpointRequest;\n\n\treturn endpointFactory;\n}\n\nmodule.exports = registerRoute;\n"]},"metadata":{},"sourceType":"script"}