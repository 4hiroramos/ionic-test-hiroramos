{"ast":null,"code":"/**\n * @module util/split-path\n */\n'use strict';\n\nvar namedGroupPattern = require('./named-group-regexp').pattern; // Convert capture groups to non-matching groups, because all capture groups\n// are included in the resulting array when an RE is passed to `.split()`\n// (We re-use the existing named group's capture pattern instead of creating\n// a new RegExp just for this purpose)\n\n\nvar patternWithoutSubgroups = namedGroupPattern.replace(/([^\\\\])\\(([^?])/g, '$1(?:$2'); // Make a new RegExp using the same pattern as one single unified capture group,\n// so the match as a whole will be preserved after `.split()`. Permit non-slash\n// characters before or after the named capture group, although those components\n// will not yield functioning setters.\n\nvar namedGroupRE = new RegExp('([^/]*' + patternWithoutSubgroups + '[^/]*)');\n/**\n * Divide a route string up into hierarchical components by breaking it apart\n * on forward slash characters.\n *\n * There are plugins (including Jetpack) that register routes with regex capture\n * groups which also contain forward slashes, so those groups have to be pulled\n * out first before the remainder of the string can be .split() as normal.\n *\n * @param {String} pathStr A route path string to break into components\n * @returns {String[]} An array of route component strings\n */\n\nmodule.exports = function (pathStr) {\n  return pathStr // Divide a string like \"/some/path/(?P<with_named_groups>)/etc\" into an\n  // array `[ \"/some/path/\", \"(?P<with_named_groups>)\", \"/etc\" ]`.\n  .split(namedGroupRE) // Then, reduce through the array of parts, splitting any non-capture-group\n  // parts on forward slashes and discarding empty strings to create the final\n  // array of path components.\n  .reduce(function (components, part) {\n    if (!part) {\n      // Ignore empty strings parts\n      return components;\n    }\n\n    if (namedGroupRE.test(part)) {\n      // Include named capture groups as-is\n      return components.concat(part);\n    } // Split the part on / and filter out empty strings\n\n\n    return components.concat(part.split('/').filter(Boolean));\n  }, []);\n};","map":{"version":3,"sources":["/Users/hiromi/ionic-react-wordpress/node_modules/wpapi/lib/util/split-path.js"],"names":["namedGroupPattern","require","pattern","patternWithoutSubgroups","replace","namedGroupRE","RegExp","module","exports","pathStr","split","reduce","components","part","test","concat","filter","Boolean"],"mappings":"AAAA;;;AAGA;;AAEA,IAAMA,iBAAiB,GAAGC,OAAO,CAAE,sBAAF,CAAP,CAAkCC,OAA5D,C,CAEA;AACA;AACA;AACA;;;AACA,IAAMC,uBAAuB,GAAGH,iBAAiB,CAC/CI,OAD8B,CACrB,kBADqB,EACD,SADC,CAAhC,C,CAGA;AACA;AACA;AACA;;AACA,IAAMC,YAAY,GAAG,IAAIC,MAAJ,CAAY,WAAWH,uBAAX,GAAqC,QAAjD,CAArB;AAEA;;;;;;;;;;;;AAWAI,MAAM,CAACC,OAAP,GAAiB,UAAAC,OAAO;AAAA,SAAIA,OAAO,CAClC;AACA;AAFkC,GAGjCC,KAH0B,CAGnBL,YAHmB,EAI3B;AACA;AACA;AAN2B,GAO1BM,MAP0B,CAOlB,UAAEC,UAAF,EAAcC,IAAd,EAAwB;AAChC,QAAK,CAAEA,IAAP,EAAc;AACb;AACA,aAAOD,UAAP;AACA;;AAED,QAAKP,YAAY,CAACS,IAAb,CAAmBD,IAAnB,CAAL,EAAiC;AAChC;AACA,aAAOD,UAAU,CAACG,MAAX,CAAmBF,IAAnB,CAAP;AACA,KAT+B,CAWhC;;;AACA,WAAOD,UAAU,CAACG,MAAX,CAAmBF,IAAI,CAACH,KAAL,CAAY,GAAZ,EAAkBM,MAAlB,CAA0BC,OAA1B,CAAnB,CAAP;AACA,GApB0B,EAoBxB,EApBwB,CAAJ;AAAA,CAAxB","sourcesContent":["/**\n * @module util/split-path\n */\n'use strict';\n\nconst namedGroupPattern = require( './named-group-regexp' ).pattern;\n\n// Convert capture groups to non-matching groups, because all capture groups\n// are included in the resulting array when an RE is passed to `.split()`\n// (We re-use the existing named group's capture pattern instead of creating\n// a new RegExp just for this purpose)\nconst patternWithoutSubgroups = namedGroupPattern\n\t.replace( /([^\\\\])\\(([^?])/g, '$1(?:$2' );\n\n// Make a new RegExp using the same pattern as one single unified capture group,\n// so the match as a whole will be preserved after `.split()`. Permit non-slash\n// characters before or after the named capture group, although those components\n// will not yield functioning setters.\nconst namedGroupRE = new RegExp( '([^/]*' + patternWithoutSubgroups + '[^/]*)' );\n\n/**\n * Divide a route string up into hierarchical components by breaking it apart\n * on forward slash characters.\n *\n * There are plugins (including Jetpack) that register routes with regex capture\n * groups which also contain forward slashes, so those groups have to be pulled\n * out first before the remainder of the string can be .split() as normal.\n *\n * @param {String} pathStr A route path string to break into components\n * @returns {String[]} An array of route component strings\n */\nmodule.exports = pathStr => pathStr\n\t// Divide a string like \"/some/path/(?P<with_named_groups>)/etc\" into an\n\t// array `[ \"/some/path/\", \"(?P<with_named_groups>)\", \"/etc\" ]`.\n\t.split( namedGroupRE )\n\t// Then, reduce through the array of parts, splitting any non-capture-group\n\t// parts on forward slashes and discarding empty strings to create the final\n\t// array of path components.\n\t.reduce( ( components, part ) => {\n\t\tif ( ! part ) {\n\t\t\t// Ignore empty strings parts\n\t\t\treturn components;\n\t\t}\n\n\t\tif ( namedGroupRE.test( part ) ) {\n\t\t\t// Include named capture groups as-is\n\t\t\treturn components.concat( part );\n\t\t}\n\n\t\t// Split the part on / and filter out empty strings\n\t\treturn components.concat( part.split( '/' ).filter( Boolean ) );\n\t}, [] );\n"]},"metadata":{},"sourceType":"script"}