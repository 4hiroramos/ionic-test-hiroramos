{"ast":null,"code":"/**\n * @module route-tree\n */\n'use strict';\n\nvar namedGroupRE = require('./util/named-group-regexp').namedGroupRE;\n\nvar splitPath = require('./util/split-path');\n\nvar ensure = require('./util/ensure');\n\nvar objectReduce = require('./util/object-reduce');\n/**\n * Method to use when reducing route components array.\n *\n * @private\n * @param {object} routeObj     A route definition object (set via .bind partial application)\n * @param {object} topLevel     The top-level route tree object for this set of routes (set\n *                              via .bind partial application)\n * @param {object} parentLevel  The memo object, which is mutated as the reducer adds\n *                              a new level handler for each level in the route\n * @param {string} component    The string defining this route component\n * @param {number} idx          The index of this component within the components array\n * @param {string[]} components The array of all components\n * @returns {object} The child object of the level being reduced\n */\n\n\nfunction reduceRouteComponents(routeObj, topLevel, parentLevel, component, idx, components) {\n  // Check to see if this component is a dynamic URL segment (i.e. defined by\n  // a named capture group regular expression). namedGroup will be `null` if\n  // the regexp does not match, or else an array defining the RegExp match, e.g.\n  // [\n  //   'P<id>[\\\\d]+)',\n  //   'id', // Name of the group\n  //   '[\\\\d]+', // regular expression for this URL segment's contents\n  //   index: 15,\n  //   input: '/wp/v2/posts/(?P<id>[\\\\d]+)'\n  // ]\n  var namedGroup = component.match(namedGroupRE); // Pull out references to the relevant indices of the match, for utility:\n  // `null` checking is necessary in case the component did not match the RE,\n  // hence the `namedGroup &&`.\n\n  var groupName = namedGroup && namedGroup[1];\n  var groupPattern = namedGroup && namedGroup[2]; // When branching based on a dynamic capture group we used the group's RE\n  // pattern as the unique identifier: this is done because the same group\n  // could be assigned different names in different endpoint handlers, e.g.\n  // \"id\" for posts/:id vs \"parent_id\" for posts/:parent_id/revisions.\n  //\n  // There is an edge case where groupPattern will be \"\" if we are registering\n  // a custom route via `.registerRoute` that does not include parameter\n  // validation. In this case we assume the groupName is sufficiently unique,\n  // and fall back to `|| groupName` for the levelKey string.\n\n  var levelKey = namedGroup ? groupPattern || groupName : component; // Level name on the other hand takes its value from the group's name, if\n  // defined, and falls back to the component string to handle situations where\n  // `component` is a collection (e.g. \"revisions\")\n\n  var levelName = namedGroup ? groupName : component; // Check whether we have a preexisting node at this level of the tree, and\n  // create a new level object if not. The component string is included so that\n  // validators can throw meaningful errors as appropriate.\n\n  var currentLevel = parentLevel[levelKey] || {\n    component: component,\n    namedGroup: namedGroup ? true : false,\n    level: idx,\n    names: []\n  }; // A level's \"names\" correspond to the list of strings which could describe\n  // an endpoint's component setter functions: \"id\", \"revisions\", etc.\n\n  if (currentLevel.names.indexOf(levelName) < 0) {\n    currentLevel.names.push(levelName);\n  } // A level's validate method is called to check whether a value being set\n  // on the request URL is of the proper type for the location in which it\n  // is specified. If a group pattern was found, the validator checks whether\n  // the input string exactly matches the group pattern.\n\n\n  var groupPatternRE = groupPattern === '' ? // If groupPattern is an empty string, accept any input without validation\n  /.*/ : // Otherwise, validate against the group pattern or the component string\n  new RegExp(groupPattern ? '^' + groupPattern + '$' : component, 'i'); // Only one validate function is maintained for each node, because each node\n  // is defined either by a string literal or by a specific regular expression.\n\n  currentLevel.validate = function (input) {\n    return groupPatternRE.test(input);\n  }; // Check to see whether to expect more nodes within this branch of the tree,\n\n\n  if (components[idx + 1]) {\n    // and create a \"children\" object to hold those nodes if necessary\n    currentLevel.children = currentLevel.children || {};\n  } else {\n    // At leaf nodes, specify the method capabilities of this endpoint\n    currentLevel.methods = (routeObj.methods || []).map(function (str) {\n      return str.toLowerCase();\n    }); // Ensure HEAD is included whenever GET is supported: the API automatically\n    // adds support for HEAD if you have GET\n\n    if (currentLevel.methods.indexOf('get') > -1 && currentLevel.methods.indexOf('head') === -1) {\n      currentLevel.methods.push('head');\n    } // At leaf nodes also flag (at the top level) what arguments are\n    // available to GET requests, so that we may automatically apply the\n    // appropriate parameter mixins\n\n\n    if (routeObj.endpoints) {\n      topLevel._getArgs = topLevel._getArgs || {};\n      routeObj.endpoints.forEach(function (endpoint) {\n        // `endpoint.methods` will be an array of methods like `[ 'GET' ]`: we\n        // only care about GET for this exercise. Validating POST and PUT args\n        // could be useful but is currently deemed to be out-of-scope.\n        endpoint.methods.forEach(function (method) {\n          if (method.toLowerCase() === 'get') {\n            Object.keys(endpoint.args).forEach(function (argKey) {\n              // Reference param definition objects in the top _getArgs dictionary\n              topLevel._getArgs[argKey] = endpoint.args[argKey];\n            });\n          }\n        });\n      });\n    }\n  } // Return the child node object as the new \"level\"\n\n\n  parentLevel[levelKey] = currentLevel;\n  return currentLevel.children;\n}\n/**\n *\n * @private\n * @param {object}   namespaces The memo object that becomes a dictionary mapping API\n *                              namespaces to an object of the namespace's routes\n * @param {object}   routeObj   A route definition object\n * @param {string}   route      The string key of the `routeObj` route object\n * @returns {object} The namespaces dictionary memo object\n */\n\n\nfunction reduceRouteTree(namespaces, routeObj, route) {\n  var nsForRoute = routeObj.namespace;\n  var routeString = route // Strip the namespace from the route string (all routes should have the\n  // format `/namespace/other/stuff`) @TODO: Validate this assumption\n  .replace('/' + nsForRoute + '/', '') // Also strip any trailing \"/?\": the slash is already optional and a single\n  // question mark would break the regex parser\n  .replace(/\\/\\?$/, ''); // Split the routes up into hierarchical route components\n\n  var routeComponents = splitPath(routeString); // Do not make a namespace group for the API root\n  // Do not add the namespace root to its own group\n  // Do not take any action if routeString is empty\n\n  if (!nsForRoute || '/' + nsForRoute === route || !routeString) {\n    return namespaces;\n  } // Ensure that the namespace object for this namespace exists\n\n\n  ensure(namespaces, nsForRoute, {}); // Get a local reference to namespace object\n\n  var ns = namespaces[nsForRoute]; // The first element of the route tells us what type of resource this route\n  // is for, e.g. \"posts\" or \"comments\": we build one handler per resource\n  // type, so we group like resource paths together.\n\n  var resource = routeComponents[0]; // @TODO: This code above currently precludes baseless routes, e.g.\n  // myplugin/v2/(?P<resource>\\w+) -- should those be supported?\n  // Create an array to represent this resource, and ensure it is assigned\n  // to the namespace object. The array will structure the \"levels\" (path\n  // components and subresource types) of this resource's endpoint handler.\n\n  ensure(ns, resource, {});\n  var levels = ns[resource]; // Recurse through the route components, mutating levels with information about\n  // each child node encountered while walking through the routes tree and what\n  // arguments (parameters) are available for GET requests to this endpoint.\n\n  routeComponents.reduce(reduceRouteComponents.bind(null, routeObj, levels), levels);\n  return namespaces;\n}\n/**\n * Build a route tree by reducing over a routes definition object from the API\n * root endpoint response object\n *\n * @method build\n * @param {object} routes A dictionary of routes keyed by route regex strings\n * @returns {object} A dictionary, keyed by namespace, of resource handler\n * factory methods for each namespace's resources\n */\n\n\nfunction buildRouteTree(routes) {\n  return objectReduce(routes, reduceRouteTree, {});\n}\n\nmodule.exports = {\n  build: buildRouteTree\n};","map":{"version":3,"sources":["/Users/hiromi/ionic-react-wordpress/node_modules/wpapi/lib/route-tree.js"],"names":["namedGroupRE","require","splitPath","ensure","objectReduce","reduceRouteComponents","routeObj","topLevel","parentLevel","component","idx","components","namedGroup","match","groupName","groupPattern","levelKey","levelName","currentLevel","level","names","indexOf","push","groupPatternRE","RegExp","validate","input","test","children","methods","map","str","toLowerCase","endpoints","_getArgs","forEach","endpoint","method","Object","keys","args","argKey","reduceRouteTree","namespaces","route","nsForRoute","namespace","routeString","replace","routeComponents","ns","resource","levels","reduce","bind","buildRouteTree","routes","module","exports","build"],"mappings":"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","sourcesContent":["/**\n * @module route-tree\n */\n'use strict';\n\nconst namedGroupRE = require( './util/named-group-regexp' ).namedGroupRE;\nconst splitPath = require( './util/split-path' );\nconst ensure = require( './util/ensure' );\nconst objectReduce = require( './util/object-reduce' );\n\n/**\n * Method to use when reducing route components array.\n *\n * @private\n * @param {object} routeObj     A route definition object (set via .bind partial application)\n * @param {object} topLevel     The top-level route tree object for this set of routes (set\n *                              via .bind partial application)\n * @param {object} parentLevel  The memo object, which is mutated as the reducer adds\n *                              a new level handler for each level in the route\n * @param {string} component    The string defining this route component\n * @param {number} idx          The index of this component within the components array\n * @param {string[]} components The array of all components\n * @returns {object} The child object of the level being reduced\n */\nfunction reduceRouteComponents( routeObj, topLevel, parentLevel, component, idx, components ) {\n\t// Check to see if this component is a dynamic URL segment (i.e. defined by\n\t// a named capture group regular expression). namedGroup will be `null` if\n\t// the regexp does not match, or else an array defining the RegExp match, e.g.\n\t// [\n\t//   'P<id>[\\\\d]+)',\n\t//   'id', // Name of the group\n\t//   '[\\\\d]+', // regular expression for this URL segment's contents\n\t//   index: 15,\n\t//   input: '/wp/v2/posts/(?P<id>[\\\\d]+)'\n\t// ]\n\tconst namedGroup = component.match( namedGroupRE );\n\t// Pull out references to the relevant indices of the match, for utility:\n\t// `null` checking is necessary in case the component did not match the RE,\n\t// hence the `namedGroup &&`.\n\tconst groupName = namedGroup && namedGroup[ 1 ];\n\tconst groupPattern = namedGroup && namedGroup[ 2 ];\n\n\t// When branching based on a dynamic capture group we used the group's RE\n\t// pattern as the unique identifier: this is done because the same group\n\t// could be assigned different names in different endpoint handlers, e.g.\n\t// \"id\" for posts/:id vs \"parent_id\" for posts/:parent_id/revisions.\n\t//\n\t// There is an edge case where groupPattern will be \"\" if we are registering\n\t// a custom route via `.registerRoute` that does not include parameter\n\t// validation. In this case we assume the groupName is sufficiently unique,\n\t// and fall back to `|| groupName` for the levelKey string.\n\tconst levelKey = namedGroup ? ( groupPattern || groupName ) : component;\n\n\t// Level name on the other hand takes its value from the group's name, if\n\t// defined, and falls back to the component string to handle situations where\n\t// `component` is a collection (e.g. \"revisions\")\n\tconst levelName = namedGroup ? groupName : component;\n\n\t// Check whether we have a preexisting node at this level of the tree, and\n\t// create a new level object if not. The component string is included so that\n\t// validators can throw meaningful errors as appropriate.\n\tconst currentLevel = parentLevel[ levelKey ] || {\n\t\tcomponent: component,\n\t\tnamedGroup: namedGroup ? true : false,\n\t\tlevel: idx,\n\t\tnames: [],\n\t};\n\n\t// A level's \"names\" correspond to the list of strings which could describe\n\t// an endpoint's component setter functions: \"id\", \"revisions\", etc.\n\tif ( currentLevel.names.indexOf( levelName ) < 0 ) {\n\t\tcurrentLevel.names.push( levelName );\n\t}\n\n\t// A level's validate method is called to check whether a value being set\n\t// on the request URL is of the proper type for the location in which it\n\t// is specified. If a group pattern was found, the validator checks whether\n\t// the input string exactly matches the group pattern.\n\tconst groupPatternRE = groupPattern === '' ?\n\t\t// If groupPattern is an empty string, accept any input without validation\n\t\t/.*/ :\n\t\t// Otherwise, validate against the group pattern or the component string\n\t\tnew RegExp( groupPattern ? '^' + groupPattern + '$' : component, 'i' );\n\n\t// Only one validate function is maintained for each node, because each node\n\t// is defined either by a string literal or by a specific regular expression.\n\tcurrentLevel.validate = input => groupPatternRE.test( input );\n\n\t// Check to see whether to expect more nodes within this branch of the tree,\n\tif ( components[ idx + 1 ] ) {\n\t\t// and create a \"children\" object to hold those nodes if necessary\n\t\tcurrentLevel.children = currentLevel.children || {};\n\t} else {\n\t\t// At leaf nodes, specify the method capabilities of this endpoint\n\t\tcurrentLevel.methods = ( routeObj.methods || [] ).map( str => str.toLowerCase() );\n\n\t\t// Ensure HEAD is included whenever GET is supported: the API automatically\n\t\t// adds support for HEAD if you have GET\n\t\tif ( currentLevel.methods.indexOf( 'get' ) > -1 && currentLevel.methods.indexOf( 'head' ) === -1 ) {\n\t\t\tcurrentLevel.methods.push( 'head' );\n\t\t}\n\n\t\t// At leaf nodes also flag (at the top level) what arguments are\n\t\t// available to GET requests, so that we may automatically apply the\n\t\t// appropriate parameter mixins\n\t\tif ( routeObj.endpoints ) {\n\t\t\ttopLevel._getArgs = topLevel._getArgs || {};\n\t\t\trouteObj.endpoints.forEach( ( endpoint ) => {\n\t\t\t\t// `endpoint.methods` will be an array of methods like `[ 'GET' ]`: we\n\t\t\t\t// only care about GET for this exercise. Validating POST and PUT args\n\t\t\t\t// could be useful but is currently deemed to be out-of-scope.\n\t\t\t\tendpoint.methods.forEach( ( method ) => {\n\t\t\t\t\tif ( method.toLowerCase() === 'get' ) {\n\t\t\t\t\t\tObject.keys( endpoint.args ).forEach( ( argKey ) => {\n\t\t\t\t\t\t\t// Reference param definition objects in the top _getArgs dictionary\n\t\t\t\t\t\t\ttopLevel._getArgs[ argKey ] = endpoint.args[ argKey ];\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t}\n\n\t// Return the child node object as the new \"level\"\n\tparentLevel[ levelKey ] = currentLevel;\n\treturn currentLevel.children;\n}\n\n/**\n *\n * @private\n * @param {object}   namespaces The memo object that becomes a dictionary mapping API\n *                              namespaces to an object of the namespace's routes\n * @param {object}   routeObj   A route definition object\n * @param {string}   route      The string key of the `routeObj` route object\n * @returns {object} The namespaces dictionary memo object\n */\nfunction reduceRouteTree( namespaces, routeObj, route ) {\n\tconst nsForRoute = routeObj.namespace;\n\n\tconst routeString = route\n\t\t// Strip the namespace from the route string (all routes should have the\n\t\t// format `/namespace/other/stuff`) @TODO: Validate this assumption\n\t\t.replace( '/' + nsForRoute + '/', '' )\n\t\t// Also strip any trailing \"/?\": the slash is already optional and a single\n\t\t// question mark would break the regex parser\n\t\t.replace( /\\/\\?$/, '' );\n\n\t// Split the routes up into hierarchical route components\n\tconst routeComponents = splitPath( routeString );\n\n\t// Do not make a namespace group for the API root\n\t// Do not add the namespace root to its own group\n\t// Do not take any action if routeString is empty\n\tif ( ! nsForRoute || '/' + nsForRoute === route || ! routeString ) {\n\t\treturn namespaces;\n\t}\n\n\t// Ensure that the namespace object for this namespace exists\n\tensure( namespaces, nsForRoute, {} );\n\n\t// Get a local reference to namespace object\n\tconst ns = namespaces[ nsForRoute ];\n\n\t// The first element of the route tells us what type of resource this route\n\t// is for, e.g. \"posts\" or \"comments\": we build one handler per resource\n\t// type, so we group like resource paths together.\n\tconst resource = routeComponents[0];\n\n\t// @TODO: This code above currently precludes baseless routes, e.g.\n\t// myplugin/v2/(?P<resource>\\w+) -- should those be supported?\n\n\t// Create an array to represent this resource, and ensure it is assigned\n\t// to the namespace object. The array will structure the \"levels\" (path\n\t// components and subresource types) of this resource's endpoint handler.\n\tensure( ns, resource, {} );\n\tconst levels = ns[ resource ];\n\n\t// Recurse through the route components, mutating levels with information about\n\t// each child node encountered while walking through the routes tree and what\n\t// arguments (parameters) are available for GET requests to this endpoint.\n\trouteComponents.reduce(\n\t\treduceRouteComponents.bind( null, routeObj, levels ),\n\t\tlevels\n\t);\n\n\treturn namespaces;\n}\n\n/**\n * Build a route tree by reducing over a routes definition object from the API\n * root endpoint response object\n *\n * @method build\n * @param {object} routes A dictionary of routes keyed by route regex strings\n * @returns {object} A dictionary, keyed by namespace, of resource handler\n * factory methods for each namespace's resources\n */\nfunction buildRouteTree( routes ) {\n\treturn objectReduce( routes, reduceRouteTree, {} );\n}\n\nmodule.exports = {\n\tbuild: buildRouteTree,\n};\n"]},"metadata":{},"sourceType":"script"}